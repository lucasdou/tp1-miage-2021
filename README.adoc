# TP MIAGE conception logicielle

NOTE: TP de deux slots de 1h20

## Nom du(des) √©tudiant(e)(s) de ce mon√¥me/bin√¥me 
WARNING: NE PAS OUBLIER DE MENTIONNER LES DEUX NOMS SI VOUS ETES EN BINOME!

Binbing Ning et Lucas Douillard

Commentaires √©ventuels des √©tudiants : #Lucas a rencontrÈ quelques problËmes pour l'utilisation de la VM il a donc d˚ installer les diffÈrents outils manuellement.#

## Pr√©-requis 

* Disposer d'un PC d'au moins 6 Gio de RAM avec 20 Gio de disque disponible ;
* Disposer d'une version recente de VirtualBox ;
* Disposer d'un compte Github par personne (ou un pour deux personnes si vous √™tes en bin√¥me) ;
* T√©l√©charger et d√©compresser l'image VirtualBox de l'environnement de d√©veloppement https://public.florat.net/cours_miage/vm-tp-miage.zip[ici] (√† faire *avant le TP*). Le login/mot de passe est : `tp`/`tp`.

## D√©roulement du TP

*R√©pondre aux questions de la feuille de TP juste sous la question* (en modifiant, commitant puis poussant le fichier `README.adoc`).

Nous fournissons diff√©rents projets Eclipse servant de base de travail aux exercices suivant. Cela permet un point de synchronisation de tous les √©tudiants √† diff√©rents moments du TP. 

TIP: Fermer chaque projet Eclipse (sans supprimer les sources) avant de passer √† l'exercice suivant pour √©viter de confondre les projets ex1 et ex2.


### Exercice 1 - Etudier une API REST sans couches
_Temps estim√© : 40 mins_

* Importer dans Eclipse les projets `todolist-debut-ex1` et `todolist-debut-ex2`.

Faire `File` -> `Import` -> `Projects from Git (with smart import)` -> `Clone URI` -> URI: `https://github.com/<x>/tp1-miage-2021.git` (conserver les autres options inchang√©es) -> 'Import projects from File System or Archives' : ne laisser cocher que `tp1-miage-2021/tolist-debut-ex1` et `tp1-miage-2021/tolist-debut-ex2` ('import as Maven') -> Bouton 'Finish'.

TIP: [Rappel Git] Trois d√©p√¥ts sont ici utilis√©s: le d√©pot Github de l'enseignant (`bflorat/tp1-miage-2021`), le d√©pot Github du bin√¥me (`<x>/tp1-miage-2021`), le d√©pot local sur le portable de l'un ou des deux √©tudiants du bin√¥me.


* Observer le code du projet `todolist-debut-ex1`

*Le code est-il structur√© en couches ? Quel probl√®mes ce code peut-il poser ?*
Non, il a une architecture monolithique, cela peut poser problËme en terme de facilitÈ d'Èvolution du programme les composants Ètant fortement interdÈpendants.

*O√π se trouve le code m√©tier (voir la r√®gle de gestion RG 1) ?*
Le code mÈtier se trouve dans le document TodoListController.java

*Cette r√®gle est-elle facilement testable par un test unitaire ?*
Non, elle ne l'est pas, car tout d'abord la mÈthode a une visibilitÈ dÈfinie sur private ce qui forcera ‡ faire le test dans la classe TodoListController, s'ajoutant a cela diverses problÈmatiques telles que les rËgles de gestion de Spring notamment.

* Lancer une base PostgreSQL en Docker dans un terminal (on lance ici la base en mode interactif pour visualiser son activit√©. Pour la lancer en t√¢che de fond, remplacer les options `it` par `d` comme 'daemon'):
```bash
docker run -it -e POSTGRES_PASSWORD=password -p 5432:5432 postgres
```
*Expliquer cette ligne de commande (y compris les options utilis√©es)*
On lance un serveur postgres sur docker avec des options -e qui permet d'ajouter des variables d'environnement, ici un mot de passe ‡ la base de donnÈes crÈÈ, et -p qui permet de "publier" un port du conteneur ‡ l'hÙte, de lui donner accËs ‡ la base via ce port.

* Compl√©ter le code manquant dans la m√©thode `TodoListController.createTodoItem()`


*Pourquoi `todoItemRepository` est-il `null` ? Quelle est la meilleure fa√ßon de l'injecter ?*
Car il manque une instruction d'injection au niveau du constructeur de TodoListController
il faudra donc ajouter @Inject au-dessus du constructeur.

* Modifier le code en cons√©quence.
* Tester vos endpoints avec un client REST.


[NOTE]
====
* Les URL des endpoints sont renseign√©es dans le contr√¥leur via les annotation `@...Mapping` 
* Exemple de body JSON : 

```json
{
    "id": "0f8-06eb17ba8d34",
    "time": "2020-02-27T10:31:43Z",
    "content": "Faire les courses"
  }
```
====

NOTE: Pour lancer l'application Spring, selectionner la classe `TodolistApplication` et faire bouton droit -> 'Run as' -> 'Java Application'.

* Quand les deux endpoints fonctionnent, commiter, faire un push vers Github et fermer le projet Eclipse (ne pas le supprimer).

* V√©rifier avec DBeaver que les donnn√©es sont bien en base PostgreSQL.

### Exercice 2 - Refactoring en architecture hexagonale
_Temps estim√© : 1 h 20_

* Partir du projet `todolist-debut-ex2`

NOTE: Le projet a √©t√© r√©usin√© suivant les principes de l'architecture hexagonale : 

image::images/archi_hexagonale.png[]
Source : http://leanpub.com/get-your-hands-dirty-on-clean-architecture[Tom Hombergs]

* Nous avons d√©coup√© le coeur en deux couches : 
  - la couche `application` qui contient tous les contrats : ports (interfaces) et les impl√©mentations des ports d'entr√©e (ou "use case") et qui servent √† orchestrer les entit√©s.
  - la couche `domain` qui contient les entit√©s (au sens DDD, pas au sens JPA). En g√©n√©ral des classes complexes (m√©thodes riches, relations entre les entit√©s)

*Rappeler en quelques lignes les grands principes de l'architecture hexagonale.*
Les dÈpendances sont de l'extÈrieur vers l'intÈrieur.
SÈparer les ÈlÈments en deux parties intÈrieures (use-cases, ports et entitÈs) et extÈrieures (Adapteurs etc).
Pattern Port adapter (adapter permettant d'abstraire l'intÈrieur de l'hexagone et donc de conserver les dÈpendances de l'extÈrieur vers l'intÈrieur).
Limiter le couplage entre les composants.

Compl√©ter ce code avec une fonctionnalit√© de cr√©ation de `TodoItem`  persist√© en base et appel√© depuis un endpoint REST `POST /todos` qui :

* prend un `TodoItem` au format JSON dans le body (voir exemple de contenu plus haut);
* renvoie un code `201` en cas de succ√®s. 

La fonctionnalit√© √† impl√©menter est contractualis√©e par le port d'entr√©e `AddTodoItem`.

### Exercice 3 - Ecriture de tests
_Temps estim√© : 20 mins_

* Rester sur le m√™me code que l'exercice 2

* Impl√©menter (en junit) des TU sur la r√®gle de gestion qui consiste √† afficher `[LATE!]` dans la description d'un item en retard de plus de 24h.
(ImplÈmentÈ dans la classe TodoItemTests qui se trouve dans le package domain)

*Quels types de tests devra-t-on √©crire pour les adapteurs ?* 
On devra Ècrire des test d'intÈgration. (indiquÈ ‡ 46:32 dans la vidÈo fournie) 

*Que teste-on dans ce cas ?*
On test si l'ensemble de l'application fonctionne bien, une fois que tous les ÈlÈments qui la composent sont rassemblÈs.

*S'il vous reste du temps, √©crire quelques uns de ces types de test.*

[TIP]
=====
- Pour tester l'adapter REST, utiliser l'annotation `@WebMvcTest(controllers = TodoListController.class)`
- Voir cette https://spring.io/guides/gs/testing-web/[documentation]
=====

### Exercice 3 du TD - Injection de dÈpendance

*…crire le pseudo code d'injection entre les classes suivantes sachant que :*

* ClientMail a besoin d'un ServerMail

* ClientMail a besoin d'un MessageFormatter (singleton)

* ServerMail a besoin d'une Connection

*Le faire avec chacune des trois types d'injection.*

* Injection par constructeur :

```java
class MailClient
{
	SmtpServer server ;
	MessageFormatter ;
	@Inject
	public MailClient(SmtpServer server,MessageFormatter formatter){
		this.server = server ; this.formatter= formatter ;
	}
	public void envoyerMail(Mail mail){
		server.send(formater.format(mail)) ;
	}
}
class SmtpServer
{
	Connexion connexion ;
	@Inject
	public SmtpServer(Connexion connexion){
		this.connexion = connexion ;
	}
	public void send(Mail mail){
		connexion.open() ;
		connexion.write(formater.format(mail)) ;
	}
}
```

* Injection par setter:

```java
class MailClient{
	SmtpServer server ;
	MessageFormatter formatter ;
	public MailClient(){}
	@Inject
	public void setServer(SmtpServer Server){
		this.server = server;
	}
	@Inject
	public void setFormatter(MessageFormatter formatter){
		this.formatter = formatter;
	}
}
class SmtpServer{
	Connexion connexion ;
	public SmtpServer(){}
	@Inject
	public void setConnexion(Connexion connexion){
		this.connexion = connexion ;
	}
}
```

* Injection par attribut:

```java
class MailClient{
	@Inject
	SmtpServer server ;
	@Inject	
	MessageFormatter formatter ;
	}
class SmtpServer{
	@Inject
	Connexion connexion ;
	}
```

*MessageFormatter manipule des beans Message sans dÈpendances. Doit-on injecter l'objet Message ?*

Non, on aura simplement besoin d'importer une librairie
